if (!person.parents || person.parents.length === 0) return 0; for (const parent of person.parents) { if (familyData[parent]) { const parentGen = calculateGeneration(parent); if (parentGen > 0) return parentGen + 1; } } return 0; } function findBloodConnection(person1, person2) { const person1Data = familyData[person1]; const person2Data = familyData[person2]; if (!person1Data || !person2Data) return null; if (person1Data.children?.includes(person2)) return { type: 'parent_child', direction: 'down' }; if (person2Data.children?.includes(person1)) return { type: 'parent_child', direction: 'up' }; if (person1Data.siblings?.includes(person2)) return { type: 'sibling' }; if (person1Data.siblings?.some(sib => familyData[sib]?.children?.includes(person2))) return { type: 'uncle_nephew', direction: 'down' }; if (person2Data.siblings?.some(sib => familyData[sib]?.children?.includes(person1))) return { type: 'uncle_nephew', direction: 'up' }; if (person1Data.siblings?.some(sib => familyData[sib]?.children?.some(nephew => familyData[nephew]?.children?.includes(person2)))) return { type: 'great_uncle_nephew', direction: 'down' }; if (person2Data.siblings?.some(sib => familyData[sib]?.children?.some(nephew => familyData[nephew]?.children?.includes(person1)))) return { type: 'great_uncle_nephew', direction: 'up' }; const p1_parents = person1Data.parents || []; const p2_parents = person2Data.parents || []; const getGrandparents = (parents) => [].concat(...parents.map(p => familyData[p]?.parents || [])); const p1_grandparents = getGrandparents(p1_parents); const p2_grandparents = getGrandparents(p2_parents); if (p1_parents.length > 0 && p2_parents.length > 0 && p1_parents.some(p1p => familyData[p1p]?.siblings?.some(sib => p2_parents.includes(sib)))) return { type: 'cousin' }; if (p1_grandparents.length > 0 && p2_grandparents.length > 0 && p1_grandparents.some(p1gp => familyData[p1gp]?.siblings?.some(sib => p2_grandparents.includes(sib)))) return { type: 'second_cousin' }; if ((p1_grandparents.length > 0 && p2_parents.length > 0 && p1_grandparents.some(p1gp => familyData[p1gp]?.siblings?.some(sib => p2_parents.includes(sib)))) || (p2_grandparents.length > 0 && p1_parents.length > 0 && p2_grandparents.some(p2gp => familyData[p2gp]?.siblings?.some(sib => p1_parents.includes(sib))))) return { type: 'second_cousin' }; const isDirectDescendant = (ancestorName, descendantName) => { let queue = [descendantName]; while (queue.length > 0) { let current = queue.shift(); if (current === ancestorName) return true; familyData[current]?.parents?.forEach(p => queue.push(p)); } return false; }; if (isDirectDescendant(person1, person2)) { const genDiff = calculateGeneration(person2) - calculateGeneration(person1); if (genDiff === 2) return { type: 'grandparent_grandchild', direction: 'down' }; if (genDiff === 3) return { type: 'great_grandparent_grandchild', direction: 'down' }; if (genDiff === 4) return { type: 'great_great_grandparent_grandchild', direction: 'down' }; } if (isDirectDescendant(person2, person1)) { const genDiff = calculateGeneration(person1) - calculateGeneration(person2); if (genDiff === 2) return { type: 'grandparent_grandchild', direction: 'up' }; if (genDiff === 3) return { type: 'great_grandparent_grandchild', direction: 'up' }; if (genDiff === 4) return { type: 'great_great_grandparent_grandchild', direction: 'up' }; } return null; } function findAffinityConnection(person1, person2) { const person1Data = familyData[person1]; const person2Data = familyData[person2]; if (!person1Data || !person2Data) return null; if (person1Data.spouse) { const connection = findBloodConnection(person1Data.spouse, person2); if (connection) return { ...connection, through_marriage: person1Data.spouse }; } if (person2Data.spouse) { const connection = findBloodConnection(person1, person2Data.spouse); if (connection) return { ...connection, through_marriage: person2Data.spouse, reverse: true }; } if (person1Data.spouse && familyData[person1Data.spouse]?.siblings?.some(sib => familyData[sib]?.spouse === person2)) { return { type: 'sibling', through_marriage: person1Data.spouse }; } if (person2Data.spouse && familyData[person2Data.spouse]?.siblings?.some(sib => familyData[sib]?.spouse === person1)) { return { type: 'sibling', through_marriage: person2Data.spouse, reverse: true }; } if (person1Data.spouse && person2Data.spouse) { const connection = findBloodConnection(person1Data.spouse, person2Data.spouse); if (connection) return { ...connection, through_marriage: person1Data.spouse }; } return null; } function connectionToRelationship(connection, startGender, endGender) { if (!connection) return null; const isAcquired = !!connection.through_marriage; switch (connection.type) { case 'spouse': return { forward: startGender === 'M' ? 'marito' : 'moglie', backward: endGender === 'M' ? 'marito' : 'moglie' }; case 'parent_child': if (connection.direction === 'down') { return isAcquired ? { forward: startGender === 'M' ? 'suocero' : 'suocera', backward: endGender === 'M' ? 'genero' : 'nuora' } : { forward: startGender === 'M' ? 'padre' : 'madre', backward: endGender === 'M' ? 'figlio' : 'figlia' }; } else { return isAcquired ? { forward: startGender === 'M' ? 'genero' : 'nuora', backward: endGender === 'M' ? 'suocero' : 'suocera' } : { forward: startGender === 'M' ? 'figlio' : 'figlia', backward: endGender === 'M' ? 'padre' : 'madre' }; } case 'sibling': return isAcquired ? { forward: startGender === 'M' ? 'cognato' : 'cognata', backward: endGender === 'M' ? 'cognato' : 'cognata' } : { forward: startGender === 'M' ? 'fratello' : 'sorella', backward: endGender === 'M' ? 'fratello' : 'sorella' }; case 'uncle_nephew': return connection.direction === 'down' ? { forward: startGender === 'M' ? 'zio' : 'zia', backward: 'nipote' } : { forward: 'nipote', backward: endGender === 'M' ? 'zio' : 'zia' }; case 'great_uncle_nephew': return connection.direction === 'down' ? { forward: startGender === 'M' ? 'prozio' : 'prozia', backward: 'pronipote' } : { forward: 'pronipote', backward: endGender === 'M' ? 'prozio' : 'prozia' }; case 'grandparent_grandchild': return connection.direction === 'down' ? { forward: startGender === 'M' ? 'nonno' : 'nonna', backward: 'nipote' } : { forward: 'nipote', backward: endGender === 'M' ? 'nonno' : 'nonna' }; case 'great_grandparent_grandchild': return connection.direction === 'down' ? { forward: startGender === 'M' ? 'bisnonno' : 'bisnonna', backward: 'pronipote' } : { forward: 'pronipote', backward: endGender === 'M' ? 'bisnonno' : 'bisnonna' }; case 'great_great_grandparent_grandchild': return connection.direction === 'down' ? { forward: startGender === 'M' ? 'trisnonno' : 'trisnonna', backward: 'trisnipote' } : { forward: 'trisnipote', backward: endGender === 'M' ? 'trisnonno' : 'trisnonna' }; case 'cousin': return { forward: startGender === 'M' ? 'cugino' : 'cugina', backward: endGender === 'M' ? 'cugino' : 'cugina' }; case 'second_cousin': return { forward: startGender === 'M' ? 'procugino' : 'procugina', backward: endGender === 'M' ? 'procugino' : 'procugina' }; } return null; } function findFullPath(startName, endName) { if (startName === endName) return null; const queue = [[startName]]; const visited = new Set([startName]); while (queue.length > 0) { const path = queue.shift(); const currentName = path[path.length - 1]; if (currentName === endName) return path; const currentData = familyData[currentName]; if (!currentData) continue; const connections = [ ...(currentData.parents || []), ...(currentData.children || []), ...(currentData.siblings || []), ...(currentData.spouse ? [currentData.spouse] : []) ]; for (const connectionName of connections) { if (connectionName && !visited.has(connectionName)) { visited.add(connectionName); const newPath = [...path, connectionName]; queue.push(newPath); } } } return null; } function buildDescriptivePath(pathArray) { if (!pathArray || pathArray.length < 2) return null; const segments = []; for (let i = 0; i < pathArray.length - 1; i++) { const from = pathArray[i]; const to = pathArray[i+1]; const fromData = familyData[from]; let rel = "→"; if (fromData.spouse === to) { rel = fromData.gender === 'M' ? 'marito di' : 'moglie di'; } else if (fromData.children?.includes(to)) { rel = fromData.gender === 'M' ? 'padre di' : 'madre di'; } else if (fromData.siblings?.includes(to)) { rel = fromData.gender === 'M' ? 'fratello di' : 'sorella di'; } else if (fromData.parents?.includes(to)) { rel = fromData.gender === 'M' ? 'figlio di' : 'figlia di'; } if (i === 0) { segments.push(`${from} (${rel}) ${to}`); } else { segments.push(`(${rel}) ${to}`); } } return segments.join(', '); } function getRelationship(startName, endName) { if (startName === endName) return null; const startPerson = familyData[startName]; const endPerson = familyData[endName]; if (!startPerson || !endPerson) return null; if (startPerson.spouse === endName) { const rel = connectionToRelationship({ type: 'spouse' }, startPerson.gender, endPerson.gender); return { a_to_b: `${rel.forward}`, b_to_a: `${rel.backward}` }; } let connection = findBloodConnection(startName, endName) || findAffinityConnection(startName, endName); if (!connection) return null; const relationship = connectionToRelationship(connection, startPerson.gender, endPerson.gender); if (!relationship) return null; return { a_to_b: `${relationship.forward}`, b_to_a: `${relationship.backward}`, path_a_to_b: buildDescriptivePath(findFullPath(startName, endName)), path_b_to_a: buildDescriptivePath(findFullPath(endName, startName)) }; } // --- Sezione Funzioni di Navigazione --- function navigateToPerson(direction) { if (selectedPeople.length !== 1) return; const currentPersonName = selectedPeople[0]; const currentIndex = orderedPersonNames.indexOf(currentPersonName); if (currentIndex === -1) return; let newIndex; if (direction === 'next') { newIndex = (currentIndex + 1) % orderedPersonNames.length; } else { newIndex = (currentIndex - 1 + orderedPersonNames.length) % orderedPersonNames.length; } const newPersonName = orderedPersonNames[newIndex]; // Deseleziona la persona corrente const currentCard = document.querySelector(`.person-card[data-name="${currentPersonName}"]`); if (currentCard) currentCard.classList.remove('selected'); // Seleziona la nuova persona const newCard = document.querySelector(`.person-card[data-name="${newPersonName}"]`); if (newCard) { selectedPeople = [newPersonName]; newCard.classList.add('selected'); updateHighlights(); updatePhotoDisplay(); updateResults(); // Scorri verso la nuova persona se necessario newCard.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } } function updateNavigationArrows() { const showArrows = selectedPeople.length === 1; const arrows = document.querySelectorAll('.navigation-arrow'); arrows.forEach(arrow => { if (showArrows) { arrow.classList.add('visible'); } else { arrow.classList.remove('visible'); } }); } // --- Sezione Funzioni UI (Interfaccia Utente) --- function renderPeople() { const getSortKey = (name) => { const person = familyData[name]; const gen = calculateGeneration(name) || getGenerationFromBirth(person.birth); const date = new Date(person.birth.split('/').reverse().join('-')).getTime(); return `${String(gen).padStart(2, '0')}-${date}`; }; const sortedNames = Object.keys(familyData).sort((a, b) => getSortKey(a).localeCompare(getSortKey(b))); // Memorizza l'ordine per la navigazione orderedPersonNames = [...sortedNames]; for (const name of sortedNames) { const data = familyData[name]; data.name = name; const card = document.createElement('div'); card.className = 'person-card'; if(data.death) card.classList.add('deceased'); card.dataset.name = name; card.addEventListener('click', () => handlePersonClick(name, card)); const photo = document.createElement('img'); photo.className = 'person-photo'; photo.src = data.photoLink; photo.alt = `Foto di ${name}`; photo.onerror = function() { this.outerHTML = `
${name.split(' ').map(n=>n[0]).join('')}
`; }; const nameEl = document.createElement('div'); nameEl.className = 'person-name'; nameEl.textContent = name; const relText = document.createElement('div'); relText.className = 'card-relationship-text'; relText.textContent = data.birth; card.append(photo, nameEl, relText); peopleGrid.appendChild(card); } } function getGenerationFromBirth(birthDate) { const year = parseInt(birthDate.split('/')[2]); if (year < 1920) return 1; if (year < 1950) return 2; if (year < 1980) return 3; if (year < 2010) return 4; return 5; } function handlePhotoClick(name) { document.querySelector(`.person-card[data-name="${name}"]`)?.click(); } function handlePersonClick(name, cardElement) { const index = selectedPeople.indexOf(name); if (index > -1) { selectedPeople.splice(index, 1); cardElement.classList.remove('selected'); } else { if (selectedPeople.length >= 2) { const firstSelected = selectedPeople.shift(); document.querySelector(`.person-card[data-name="${firstSelected}"]`)?.classList.remove('selected'); } selectedPeople.push(name); cardElement.classList.add('selected'); } updateHighlights(); updatePhotoDisplay(); updateResults(); updateNavigationArrows(); } function clearHighlights() { document.querySelectorAll('.person-card').forEach(card => { card.classList.remove('relative-highlight'); const relText = card.querySelector('.card-relationship-text'); if (relText) relText.textContent = familyData[card.dataset.name].birth; }); } function updateHighlights() { clearHighlights(); infoButton.classList.add('hidden'); if (selectedPeople.length !== 1) return; infoButton.classList.remove('hidden'); const selectedName = selectedPeople[0]; for (const otherName in familyData) { if (otherName === selectedName) continue; const relationship = getRelationship(otherName, selectedName); if (relationship) { const card = document.querySelector(`[data-name="${otherName}"]`); if (card) { card.classList.add('relative-highlight'); const relTextDiv = card.querySelector('.card-relationship-text'); if(relTextDiv) { const tempDiv = document.createElement('div'); tempDiv.innerHTML = relationship.a_to_b; let displayText = (tempDiv.textContent || tempDiv.innerText || "").trim(); relTextDiv.textContent = displayText.charAt(0).toUpperCase() + displayText.slice(1); } } } } } function updatePhotoDisplay() { resultsContainer.classList.toggle('hidden', selectedPeople.length === 0); const displays = [photoDisplay1, photoDisplay2]; displays.forEach((display, index) => { display.innerHTML = ''; display.classList.remove('visible'); if (selectedPeople[index]) { const personName = selectedPeople[index]; const personData = familyData[personName]; if (personData) { let content = `${personName}`; // Aggiungi le frecce solo alla prima foto quando è selezionata una sola persona if (index === 0 && selectedPeople.length === 1) { content += ` `; } display.innerHTML = content; setTimeout(() => display.classList.add('visible'), 50); } } }); // Riassegna gli event listener alle frecce dopo aver aggiornato il DOM const newPrevBtn = document.getElementById('prev-person'); const newNextBtn = document.getElementById('next-person'); if (newPrevBtn && newNextBtn) { newPrevBtn.addEventListener('click', (e) => { e.stopPropagation(); navigateToPerson('prev'); }); newNextBtn.addEventListener('click', (e) => { e.stopPropagation(); navigateToPerson('next'); }); } updateNavigationArrows(); } function updateResults() { if (selectedPeople.length === 0) { resultsText.innerHTML = 'In attesa della selezione...'; resultsText.className = 'placeholder'; return; } if (selectedPeople.length === 1) { resultsText.innerHTML = `${selectedPeople[0]} selezionato...`; resultsText.className = ''; return; } resultsText.className = ''; const [personA_name, personB_name] = selectedPeople; const relationship = getRelationship(personA_name, personB_name); if (!relationship) { resultsText.innerHTML = `Nessun legame di parentela noto tra ${personA_name} e ${personB_name}.`; resultsText.className = 'placeholder'; return; } const result1 = `${personA_name} è ${relationship.a_to_b} di ${personB_name}`; const result2 = `${personB_name} è ${relationship.b_to_a} di ${personA_name}`; let fullResult = result1; if (relationship.path_a_to_b) { fullResult += `
${relationship.path_a_to_b}
`; } fullResult += `

${result2}`; if (relationship.path_b_to_a && relationship.path_b_to_a !== relationship.path_a_to_b) { fullResult += `
${relationship.path_b_to_a}
`; } resultsText.innerHTML = fullResult; } // Event listeners per le frecce di navigazione iniziali if (prevPersonBtn && nextPersonBtn) { prevPersonBtn.addEventListener('click', (e) => { e.stopPropagation(); navigateToPerson('prev'); }); nextPersonBtn.addEventListener('click', (e) => { e.stopPropagation(); navigateToPerson('next'); }); } infoButton.addEventListener('click', () => { if (selectedPeople.length !== 1) return; const selectedName = selectedPeople[0]; const selectedPersonData = familyData[selectedName]; if (!selectedPersonData) return; const orderedNames = Array.from(document.querySelectorAll('#people-grid .person-card')).map(card => card.dataset.name); const selectedBirthYear = selectedPersonData.birth.split('/')[2]; const groupMap = { 'Nonno': 'Nonni', 'Nonna': 'Nonni', 'Suocero': 'Suoceri', 'Suocera': 'Suoceri', 'Marito': 'Marito', 'Moglie': 'Moglie', 'Padre': 'Genitori', 'Madre': 'Genitori', 'Figlio': 'Figli', 'Figlia': 'Figli', 'Fratello': 'Fratelli', 'Sorella': 'Fratelli', 'Cognato': 'Cognati', 'Cognata': 'Cognati', 'Zio': 'Zii', 'Zia': 'Zii', 'Nipote': 'Nipoti', 'Cugino': 'Cugini', 'Cugina': 'Cugini', 'Prozio': 'Prozii', 'Prozia': 'Prozii', 'Pronipote': 'Pronipoti', 'Procugino': 'Procugini', 'Procugina': 'Procugini', 'Trisnonno': 'Trisnonni', 'Trisnonna': 'Trisnonni', 'Trisnipote': 'Trisnipoti' }; const groupedRelatives = {}; for (const otherName of orderedNames) { if (otherName === selectedName) continue; const relationship = getRelationship(otherName, selectedName); if (relationship?.a_to_b) { const tempDiv = document.createElement('div'); tempDiv.innerHTML = relationship.a_to_b; let term = (tempDiv.textContent || tempDiv.innerText || "").trim(); if(term) { term = term.charAt(0).toUpperCase() + term.slice(1); const group = groupMap[term] || term; if (!groupedRelatives[group]) { groupedRelatives[group] = []; } groupedRelatives[group].push({ name: otherName, gender: familyData[otherName].gender, birth: familyData[otherName].birth }); } } } for (const groupName in groupedRelatives) { groupedRelatives[groupName].sort((a, b) => { const dateA = new Date(a.birth.split('/').reverse().join('-')); const dateB = new Date(b.birth.split('/').reverse().join('-')); return dateA - dateB; }); } if (groupedRelatives['Fratelli'] && groupedRelatives['Fratelli'].every(person => person.gender === 'F')) { groupedRelatives['Sorelle'] = groupedRelatives['Fratelli']; delete groupedRelatives['Fratelli']; } const groupOrder = ['Trisnonni', 'Bisnonni', 'Nonni', 'Suoceri', 'Genitori', 'Marito', 'Moglie', 'Figli', 'Fratelli', 'Sorelle', 'Prozii', 'Zii', 'Cognati', 'Cugini', 'Procugini', 'Nipoti', 'Pronipoti', 'Trisnipoti']; let htmlList = `
`; let clipboardText = `${selectedName} (${selectedBirthYear})\n---\n`; for (const groupName of groupOrder) { if (groupedRelatives[groupName]) { const peopleInGroup = groupedRelatives[groupName]; const firstNames = peopleInGroup.map(person => person.name.split(' ')[0]).join(', '); const fullNames = peopleInGroup.map(person => person.name).join(', '); clipboardText += `- ${groupName}: ${firstNames}\n`; htmlList += `
${groupName}
${fullNames}

`; } } htmlList += `
`; modalTitle.textContent = selectedName; modalBody.innerHTML = htmlList; if (navigator.clipboard) { navigator.clipboard.writeText(clipboardText).catch(err => console.error("Impossibile copiare negli appunti:", err)); } infoModalOverlay.classList.remove('hidden'); }); function closeModal() { infoModalOverlay.classList.add('hidden'); } function generateImage() { const elementToCapture = document.querySelector("#info-modal-overlay .modal-content"); const modalBodyEl = document.querySelector("#info-modal-overlay .modal-body"); const selectedName = selectedPeople[0] || 'parentela'; if (!elementToCapture || !modalBodyEl) return; // Salva gli stili originali per ripristinarli dopo const originalStyles = { maxHeight: elementToCapture.style.maxHeight, overflowY: modalBodyEl.style.overflowY, alignItems: infoModalOverlay.style.alignItems }; // Modifica temporaneamente gli stili per catturare tutto il contenuto elementToCapture.style.maxHeight = 'none'; modalBodyEl.style.overflowY = 'visible'; infoModalOverlay.style.alignItems = 'flex-start'; // Allinea in alto per catturare dall'inizio html2canvas(elementToCapture, { scale: 2, useCORS: true, backgroundColor: '#ffffff' }).then(canvas => { const fileName = `parentela-${selectedName.replace(/ /g, '_')}.jpg`; const file = new File([],""); // Placeholder per la condivisione // Converte il canvas in un blob per la condivisione canvas.toBlob(function(blob) { const file = new File([blob], fileName, { type: 'image/jpeg' }); // Controlla se l'API di condivisione è disponibile (su mobile) if (navigator.share && navigator.canShare({ files: [file] })) { navigator.share({ files: [file], title: `Parentela di ${selectedName}`, }).catch(err => { if (err.name !== 'AbortError') console.error("Errore di condivisione:", err) }); } else { // Fallback per desktop: download diretto const link = document.createElement('a'); link.download = fileName; link.href = canvas.toDataURL('image/jpeg', 0.95); link.click(); } }, 'image/jpeg', 0.95); }).catch(err => { console.error("Errore durante la creazione dell'immagine:", err); }).finally(() => { // Ripristina sempre gli stili originali elementToCapture.style.maxHeight = originalStyles.maxHeight; modalBodyEl.style.overflowY = originalStyles.overflowY; infoModalOverlay.style.alignItems = originalStyles.alignItems; }); } modalCloseBtn.addEventListener('click', closeModal); imageButton.addEventListener('click', generateImage); infoModalOverlay.addEventListener('click', (e) => { if (e.target === infoModalOverlay) closeModal(); }); window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && !infoModalOverlay.classList.contains('hidden')) closeModal(); // Aggiungi navigazione con tastiera if (selectedPeople.length === 1) { if (e.key === 'ArrowLeft') { e.preventDefault(); navigateToPerson('prev'); } else if (e.key === 'ArrowRight') { e.preventDefault(); navigateToPerson('next'); } } }); window.handlePhotoClick = handlePhotoClick; document.addEventListener('DOMContentLoaded', () => { renderPeople(); const sw = './sw.js'; if ('serviceWorker' in navigator) { navigator.serviceWorker.register(sw).then(() => console.log('ServiceWorker registrato')).catch(err => console.error('Registrazione ServiceWorker fallita:', err)); } });
Calcolatore di Parentela
Seleziona due membri della famiglia Pricci per scoprire la loro relazione.

Aggiunte frecce di navigazione
