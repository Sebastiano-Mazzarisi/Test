<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Corri</title>

    <meta property="og:title" content="Corri">
    <meta property="og:description" content="Corri - Un gioco endless runner creato con HTML e JavaScript.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://sebastiano-mazzarisi.github.io/Test/Corri.html">
    <meta property="og:image" content="https://github.com/Sebastiano-Mazzarisi/Test/blob/main/Runner.png?raw=true">
    <meta property="og:image:width" content="192">
    <meta property="og:image:height" content="192">
    
    <link rel="icon" href="https://github.com/Sebastiano-Mazzarisi/Test/blob/main/Runner.png?raw=true">
    <link rel="apple-touch-icon" href="https://github.com/Sebastiano-Mazzarisi/Test/blob/main/Runner.png?raw=true">

    <meta name="apple-mobile-web-app-title" content="Corri">
    <meta name="application-name" content="Corri">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#f0f0f0">
    
    <link rel="manifest" href='data:application/manifest+json,%7B%22name%22%3A%22Corri%22%2C%22short_name%22%3A%22Corri%22%2C%22start_url%22%3A%22.%22%2C%22display%22%3A%22standalone%22%2C%22background_color%22%3A%22%23f0f0f0%22%2C%22theme_color%22%3A%22%23f0f0f0%22%2C%22icons%22%3A%5B%7B%22src%22%3A%22https%3A//github.com/Sebastiano-Mazzarisi/Test/blob/main/Runner.png%3Fraw%3Dtrue%22%2C%22sizes%22%3A%22192x192%22%2C%22type%22%3A%22image/png%22%2C%22purpose%22%3A%22any%20maskable%22%7D%2C%7B%22src%22%3A%22https%3A//github.com/Sebastiano-Mazzarisi/Test/blob/main/Runner.png%3Fraw%3Dtrue%22%2C%22sizes%22%3A%22512x512%22%2C%22type%22%3A%22image/png%22%2C%22purpose%22%3A%22any%20maskable%22%7D%5D%7D' />

    <style>
        body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #f0f0f0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        canvas { cursor: pointer; width: 100vw; height: 100vh; display: block; }
        #rotate-message { display: none; flex-direction: column; justify-content: center; align-items: center; width: 100%; height: 100%; background-color: #f0f0f0; text-align: center; font-size: 1.2em; }
        #rotate-message img { width: 100px; height: 100px; margin-bottom: 20px; }
        @media (orientation: portrait) { #gameCanvas { display: none; } #rotate-message { display: flex; } }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    
    <div id="rotate-message">
        <img src="https://github.com/Sebastiano-Mazzarisi/Test/blob/main/Runner.png?raw=true" alt="Runner Icon">
        <h2 id="version-text-rotate"></h2>
        <p>Per favore, ruota il dispositivo<br>in orizzontale per giocare.</p>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameVersion = "2.0 Corri (Fullscreen)";
        document.getElementById('version-text-rotate').textContent = 'Corri';

        const runnerImage = new Image();
        runnerImage.src = 'https://github.com/Sebastiano-Mazzarisi/Test/blob/main/Runner.png?raw=true';

        // === CONFIG AUDIO MP3 ===
        const MP3_JUMP_URL = "jump.mp3";
        const MP3_FAIL_URL = "fail.mp3";
        const MP3_INFO_URL = "info.mp3";

        const jumpSound = new Audio(MP3_JUMP_URL);
        const failSound = new Audio(MP3_FAIL_URL);
        let infoAudio = null;

        jumpSound.preload = 'auto';
        failSound.preload = 'auto';
        jumpSound.volume = 0.35;
        failSound.volume = 0.45;

        let audioUnlocked = false;
        function unlockAudio() {
            if (audioUnlocked) return;
            audioUnlocked = true;
            const tryPlay = (el) => {
                if (!el) return;
                const prevVol = el.volume;
                el.volume = 0.0001;
                el.play().then(() => { el.pause(); el.currentTime = 0; el.volume = prevVol; }).catch(() => { el.volume = prevVol; });
            };
            tryPlay(jumpSound);
            tryPlay(failSound);
        }

        function playSound(type) {
            if (type === 'jump') {
                jumpSound.currentTime = 0;
                jumpSound.play().catch(()=>{});
            } else if (type === 'fail') {
                failSound.currentTime = 0;
                failSound.play().catch(()=>{});
            }
        }

        function playInfoAudio() {
            if (!MP3_INFO_URL) return;
            unlockAudio();
            if (!infoAudio) {
                infoAudio = new Audio(MP3_INFO_URL);
                infoAudio.preload = 'auto';
                infoAudio.volume = 0.6;
            }
            infoAudio.currentTime = 0;
            infoAudio.play().catch(()=>{});
        }

        function stopInfoAudio() {
            if (infoAudio) { infoAudio.pause(); infoAudio.currentTime = 0; }
        }

        // === CONFIGURAZIONE GIOCO ===
        const PLAYER_NAME = "Andrea Volpe";
        const SIGN_TEXTS = ['Bari','Altamura','Trento','Ferrara','Roma','Napoli'];
        const SPECTATOR_NAMES = ['Pierluigi', 'Miriam', 'Mariasofia', 'Rino', 'Anna', 'Maria', 'Angelo', 'Mauro', 'Diletta', 'Sara', 'Pietro', 'Thomas', 'Alessio', 'Luigi'];
        const difficulties = {
            facile: { name: 'Facile', initialSpeed: 220, speedIncrement: 4, minObstacleInterval: 1.6, maxObstacleInterval: 3.0 },
            medio: { name: 'Medio', initialSpeed: 370, speedIncrement: 10, minObstacleInterval: 1.3, maxObstacleInterval: 2.4 },
            difficile: { name: 'Difficile', initialSpeed: 610, speedIncrement: 18, minObstacleInterval: 1.0, maxObstacleInterval: 1.9 }
        };

        // === VARIABILI DI GIOCO ===
        let score = 0, highscore = 0, isAlive = false, hasStarted = false, totalTime = 0, gameSpeed = 0, nextObstacleTime = 0;
        let isDemoMode = false, demoDayCount = 0;
        const GRAVITY = 2200, JUMP_FORCE = -750;
        let GROUND_Y;
        const INITIAL_LIVES = 3; let lives = 0; let isInvincible = false;
        let invincibilityTimer = 0, screenFlashTimer = 0, lastTime = 0;
        const difficultyButtons = [];
        let currentDifficulty = {};
        let showInfoScreen = false;
        let showCastScreen = false;

        // --- PAESAGGIO E OGGETTI ---
        // (Il codice per paesaggio, meteo, personaggi etc. Ã¨ corretto e viene omesso per brevitÃ )
        const DAY_CYCLE_DURATION = 120; let landscapeLayers = [], mountains = [], stars = [], clouds = [], signs = [], spectators = []; let timeOfDay = 0; let currentSignIndex = 0, nextSignTime = 0, nextSpectatorTime = 0; let currentSpectatorIndex = 0; const skyColors = {dawn: {r: 255, g: 182, b: 193}, noon: {r: 135, g: 206, b: 235}, dusk: {r: 255, g: 165, b: 0}, night: {r: 25, g: 25, b: 112}};
        const leon = { x: 0, y: 0, width: 18, height: 12, velocityX: 0, direction: 1, baseSpeed: 200, animationTime: 0, movementPhase: 'forward', minX: 0, maxX: 0, update(dt, viewWidth) { this.animationTime += dt * 15; this.minX = personaggio.x - 50; this.maxX = personaggio.x + viewWidth * 0.5; if (this.movementPhase === 'forward') { this.velocityX = gameSpeed * 0.12 + this.baseSpeed * 0.7; this.direction = 1; if (this.x >= this.maxX) { this.movementPhase = 'backward'; this.direction = -1; } } else { this.velocityX = gameSpeed * 0.15 - this.baseSpeed * 0.8; this.direction = -1; if (this.x <= this.minX) { this.movementPhase = 'forward'; this.direction = 1; } } this.x += this.velocityX * dt; if (this.x < this.minX) { this.x = this.minX; this.movementPhase = 'forward'; this.direction = 1; } if (this.x > this.maxX) { this.x = this.maxX; this.movementPhase = 'backward'; this.direction = -1; } this.y = GROUND_Y; }, draw() { ctx.save(); ctx.fillStyle = '#FFFFFF'; ctx.strokeStyle = '#CCCCCC'; ctx.lineWidth = 1; ctx.beginPath(); ctx.ellipse(this.x, this.y - 6, 10, 5, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.arc(this.x + (this.direction * 6), this.y - 8, 4, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#FFB6C1'; ctx.beginPath(); ctx.arc(this.x + (this.direction * 8), this.y - 8, 1.5, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#F0F0F0'; ctx.strokeStyle = '#CCCCCC'; ctx.lineWidth = 0.5; ctx.beginPath(); ctx.ellipse(this.x + (this.direction * 4), this.y - 10, 2, 3, this.direction * 0.3, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(this.x + (this.direction * 7), this.y - 10, 2, 3, this.direction * -0.2, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#000000'; ctx.beginPath(); ctx.arc(this.x + (this.direction * 7), this.y - 9, 0.8, 0, Math.PI * 2); ctx.fill(); const speedMultiplier = Math.abs(this.velocityX) / this.baseSpeed; const legAnimation = Math.sin(this.animationTime * (1.5 + speedMultiplier)) * 2; ctx.fillStyle = '#FFFFFF'; ctx.strokeStyle = '#CCCCCC'; ctx.lineWidth = 0.5; [{x: this.x - 6, offset: legAnimation},{x: this.x - 2, offset: -legAnimation},{x: this.x + 2, offset: legAnimation},{x: this.x + 6, offset: -legAnimation}].forEach(leg => { ctx.beginPath(); ctx.arc(leg.x, this.y - 2 + leg.offset, 1, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); }); const tailSpeed = 3 + (Math.abs(this.velocityX) / this.baseSpeed); const tailWag = Math.sin(this.animationTime * tailSpeed) * 6; let tailDirection = (this.movementPhase === 'forward') ? -1 : 1; ctx.strokeStyle = '#FFFFFF'; ctx.fillStyle = '#FFFFFF'; ctx.lineWidth = 2; ctx.lineCap = 'round'; const tailBaseX = this.x - (tailDirection * 8); const tailBaseY = this.y - 6; const tailEndX = tailBaseX - (tailDirection * 8) + tailWag; const tailEndY = tailBaseY - 4; ctx.beginPath(); ctx.moveTo(tailBaseX, tailBaseY); ctx.quadraticCurveTo(tailBaseX - (tailDirection * 4), tailBaseY - 2, tailEndX, tailEndY); ctx.stroke(); ctx.beginPath(); ctx.arc(tailEndX, tailEndY, 1.5, 0, Math.PI * 2); ctx.fill(); this.drawName(); ctx.restore(); }, drawName() { const boxWidth = 80, boxHeight = 25; const nameX = this.x; const nameY = this.y - 20; const boxX = nameX - boxWidth / 2; const boxY = nameY - boxHeight; ctx.strokeStyle = 'black'; ctx.lineWidth = 0.8; ctx.beginPath(); ctx.moveTo(nameX, this.y - 12); ctx.lineTo(nameX, boxY + boxHeight); ctx.stroke(); ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.strokeStyle = 'black'; ctx.lineWidth = 1; ctx.fillRect(boxX, boxY, boxWidth, boxHeight); ctx.strokeRect(boxX, boxY, boxWidth, boxHeight); ctx.fillStyle = 'black'; ctx.font = '16px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(PLAYER_NAME, nameX, boxY + boxHeight / 2); } };
        let isRaining = false; let rainDuration = 0; let rainIntensity = 0; let rainParticles = []; let timeToNextRain = 30 + Math.random() * 60; const RAIN_DURATION_MIN = 20, RAIN_DURATION_MAX = 30; function toggleRain(dt) { timeToNextRain -= dt; if (!isRaining && timeToNextRain <= 0) { isRaining = true; rainDuration = RAIN_DURATION_MIN + Math.random() * (RAIN_DURATION_MAX - RAIN_DURATION_MIN); rainIntensity = 0; rainParticles = []; const viewWidth = window.innerWidth; const viewHeight = window.innerHeight; for(let i=0; i<300; i++) { rainParticles.push({ x: Math.random() * viewWidth, y: Math.random() * viewHeight, length: 5 + Math.random() * 10 }); } } if (isRaining) { rainDuration -= dt; if (rainDuration <= 0) { isRaining = false; timeToNextRain = 30 + Math.random() * 60; } rainIntensity = Math.min(1, rainIntensity + dt / 5); } }
        function drawRain(dt) { if (!isRaining && rainIntensity <= 0) return; const viewWidth = window.innerWidth; const viewHeight = window.innerHeight; ctx.strokeStyle = `rgba(173, 216, 230, ${rainIntensity * 0.7})`; ctx.lineWidth = 1; for(let i=0; i<rainParticles.length; i++) { const p = rainParticles[i]; p.x -= gameSpeed * dt * 0.5; p.y += (gameSpeed * 0.5 + 200) * dt; if (p.y > viewHeight) { p.y = 0; p.x = Math.random() * viewWidth; } ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - 2, p.y + p.length); ctx.stroke(); } }
        function lerpColor(c1, c2, f) { const r = Math.round(c1.r + f * (c2.r - c1.r)), g = Math.round(c1.g + f * (c2.g - c1.g)), b = Math.round(c1.b + f * (c2.b - c1.b)); return `rgb(${r},${g},${b})`; }
        function getSkyColor(simulatedHour) { let color; if (simulatedHour >= 5 && simulatedHour < 7) { color = lerpColor(skyColors.night, skyColors.dawn, (simulatedHour - 5) / 2); } else if (simulatedHour >= 7 && simulatedHour < 9) { color = lerpColor(skyColors.dawn, skyColors.noon, (simulatedHour - 7) / 2); } else if (simulatedHour >= 9 && simulatedHour < 17) { color = `rgb(${skyColors.noon.r}, ${skyColors.noon.g}, ${skyColors.noon.b})`; } else if (simulatedHour >= 17 && simulatedHour < 19) { color = lerpColor(skyColors.noon, skyColors.dusk, (simulatedHour - 17) / 2); } else if (simulatedHour >= 19 && simulatedHour < 21) { color = lerpColor(skyColors.dusk, skyColors.night, (simulatedHour - 19) / 2); } else { color = `rgb(${skyColors.night.r}, ${skyColors.night.g}, ${skyColors.night.b})`; } if (isRaining) { const rainFactor = rainIntensity * 0.5; const comps = color.match(/\d+/g).map(Number); return `rgb(${Math.round(comps[0]*(1-rainFactor))}, ${Math.round(comps[1]*(1-rainFactor))}, ${Math.round(comps[2]*(1-rainFactor))})`; } return color; }
        function drawSky(simulatedHour) { const viewWidth = window.innerWidth; const viewHeight = window.innerHeight; ctx.fillStyle = getSkyColor(simulatedHour); ctx.fillRect(0, 0, viewWidth, viewHeight); if (simulatedHour > 6 && simulatedHour < 18 && !isRaining) { const sunProgress = (simulatedHour - 6) / 12; const sunAngle = sunProgress * Math.PI; const sunX = sunProgress * viewWidth; const sunY = GROUND_Y - Math.sin(sunAngle) * (viewHeight * 0.7); ctx.fillStyle = `rgba(255,255,0,0.8)`; ctx.beginPath(); ctx.arc(sunX, sunY, 20, 0, Math.PI * 2); ctx.fill(); } if (simulatedHour > 18 || simulatedHour < 6 || isRaining) { let moonProgress = (simulatedHour > 18) ? (simulatedHour - 18) / 12 : (simulatedHour + 6) / 12; const moonAngle = moonProgress * Math.PI; const moonX = moonProgress * viewWidth; const moonY = GROUND_Y - Math.sin(moonAngle) * (viewHeight * 0.6); const nightIntensity = 1 - (Math.abs(simulatedHour - 12) / 12); ctx.fillStyle = `rgba(240,240,240,0.8)`; ctx.beginPath(); ctx.arc(moonX, moonY, 15, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = getSkyColor(simulatedHour); ctx.beginPath(); ctx.arc(moonX - 5, moonY - 5, 14, 0, Math.PI * 2); ctx.fill(); stars.forEach(s => { ctx.fillStyle = `rgba(255,255,255,${nightIntensity * (0.7 + Math.random() * 0.3)})`; ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, 2 * Math.PI); ctx.fill(); }); } }
        function initLandscape() { const viewWidth = window.innerWidth; const viewHeight = window.innerHeight; landscapeLayers = []; mountains = []; stars = [], clouds = []; signs = [], spectators = []; const RENDER_WIDTH = viewWidth * 4; for (let i = 0; i < 150; i++) { stars.push({ x: Math.random() * viewWidth, y: Math.random() * viewHeight * 0.6, r: Math.random() * 1.8 }); } for (let i = 0; i < 15; i++) { clouds.push({ x: Math.random() * viewWidth, y: Math.random() * viewHeight * 0.3, r: 20 + Math.random() * 20, speed: 5 + Math.random() * 5 }); } let mPoints = []; for (let x = -RENDER_WIDTH; x <= RENDER_WIDTH * 2; x += 100) { mPoints.push({ x: x, y: GROUND_Y - 150 - Math.random() * 50 }); } mountains.push({ points: mPoints, color: '#A0A0A0', speedMultiplier: 0.1, offsetX: 0 }); let p3 = []; for (let x = -RENDER_WIDTH; x <= RENDER_WIDTH * 2; x += 60) { p3.push({ x: x, y: GROUND_Y - 15 - Math.random() * 25 }); } const obj3 = []; const objectTypes = ['house', 'sheep', 'tree', 'horse', 'tractor', 'car']; for (let i = 0; i < 120; i++) { const x = -RENDER_WIDTH + Math.random() * (RENDER_WIDTH * 3); let randType = objectTypes[Math.floor(Math.random() * objectTypes.length)]; const objData = { type: randType, x: x, y: getTerrainY(x, p3) }; obj3.push(objData); } obj3.sort((a, b) => a.x - b.x); landscapeLayers.push({ points: p3, color: '#8FBC8F', speedMultiplier: 0.4, offsetX: 0, objects: obj3 }); }
        function getTerrainY(x, points) { const p1 = points.slice().reverse().find(p => p.x <= x); const p2 = points.find(p => p.x > x); if (p1 && p2) { const m = (p2.y - p1.y) / (p2.x - p1.x); return p1.y + m * (x - p1.x); } return p1 ? p1.y : GROUND_Y; }
        function drawLandscape(simulatedHour) { const viewWidth = window.innerWidth; mountains.forEach(l => { ctx.fillStyle = l.color; ctx.beginPath(); ctx.moveTo(l.points[0].x + l.offsetX - viewWidth, window.innerHeight); l.points.forEach(p => { ctx.lineTo(p.x + l.offsetX, p.y); }); ctx.lineTo(l.points[l.points.length - 1].x + l.offsetX + viewWidth, window.innerHeight); ctx.closePath(); ctx.fill(); }); landscapeLayers.forEach(l => { ctx.fillStyle = l.color; ctx.beginPath(); ctx.moveTo(l.points[0].x + l.offsetX - viewWidth, window.innerHeight); l.points.forEach(p => { ctx.lineTo(p.x + l.offsetX, p.y); }); ctx.lineTo(l.points[l.points.length - 1].x + l.offsetX + viewWidth, window.innerHeight); ctx.closePath(); ctx.fill(); l.objects.forEach(obj => { drawLandscapeObject(obj, l.offsetX, simulatedHour); }); }); }
        function drawLandscapeObject(obj, offsetX, simulatedHour) { const x = obj.x + offsetX; const y = obj.y; const isNight = simulatedHour > 19 || simulatedHour < 6; if (!obj.details) obj.details = {}; switch (obj.type) { case 'house': if (isNight) return; if (!obj.details.width) obj.details = { width: 40 + Math.random() * 20, height: 30 + Math.random() * 15, color: `hsl(${Math.random() * 30 + 10},40%,70%)`, roofColor: `hsl(${Math.random() * 20 + 5},50%,45%)` }; const h = obj.details; ctx.fillStyle = h.color; ctx.fillRect(x - h.width / 2, y - h.height, h.width, h.height); if (isNight) { ctx.fillStyle = 'yellow'; ctx.fillRect(x - h.width / 4, y - h.height / 2, h.width / 4, h.height / 4); } ctx.fillStyle = h.roofColor; ctx.beginPath(); ctx.moveTo(x - h.width / 2 - 5, y - h.height); ctx.lineTo(x + h.width / 2 + 5, y - h.height); ctx.lineTo(x, y - h.height - 20); ctx.closePath(); ctx.fill(); break; case 'tree': if (!obj.details.height) obj.details = { height: 20 + Math.random() * 30, radius: 6 + Math.random() * 6 }; const t = obj.details; ctx.fillStyle = '#8B4513'; ctx.fillRect(x - 2, y - t.height, 4, t.height); ctx.fillStyle = `hsl(120,60%,${25 + Math.random() * 10}%)`; ctx.beginPath(); ctx.arc(x, y - t.height, t.radius, 0, Math.PI * 2); ctx.arc(x + t.radius / 2, y - t.height - 5, t.radius * 0.8, 0, Math.PI * 2); ctx.arc(x - t.radius / 2, y - t.height - 5, t.radius * 0.8, 0, Math.PI * 2); ctx.arc(x, y - t.height + 3, t.radius * 0.7, 0, Math.PI * 2); ctx.arc(x + t.radius / 3, y - t.height - 8, t.radius * 0.6, 0, Math.PI * 2); ctx.arc(x - t.radius / 3, y - t.height - 8, t.radius * 0.6, 0, Math.PI * 2); ctx.arc(x + t.radius * 0.7, y - t.height + 1, t.radius * 0.5, 0, Math.PI * 2); ctx.arc(x - t.radius * 0.7, y - t.height + 1, t.radius * 0.5, 0, Math.PI * 2); ctx.fill(); break; case 'sheep': case 'horse': case 'tractor': case 'car': if (isNight) return; if (obj.type === 'sheep') { if (!obj.details.state) obj.details = { state: 'down', timer: Math.random() * 3 }; const s = obj.details; ctx.fillStyle = '#FFFFFF'; ctx.beginPath(); ctx.arc(x, y - 10, 6, 0, Math.PI * 2); ctx.arc(x + 5, y - 12, 5, 0, Math.PI * 2); ctx.arc(x - 5, y - 12, 5, 0, Math.PI * 2); ctx.fill(); let sHeadY = (s.state === 'down') ? y - 8 : y - 18; ctx.fillStyle = '#333333'; ctx.beginPath(); ctx.arc(x + 10, sHeadY, 4, 0, Math.PI * 2); ctx.fill(); } else if (obj.type === 'horse') { if (!obj.details.state) obj.details = { state: 'down', timer: Math.random() * 3, color: `hsl(30,50%,${20 + Math.random() * 15}%)` }; const p = obj.details; ctx.fillStyle = p.color; ctx.beginPath(); ctx.ellipse(x, y - 15, 12, 8, 0, 0, Math.PI * 2); ctx.fill(); let pHeadY = (p.state === 'down') ? y - 15 : y - 25; ctx.beginPath(); ctx.arc(x + 15, pHeadY, 5, 0, Math.PI * 2); ctx.fill(); ctx.fillRect(x - 10, y - 10, 2, 10); ctx.fillRect(x + 5, y - 10, 2, 10); } else if (obj.type === 'tractor') { ctx.fillStyle = 'red'; ctx.fillRect(x - 15, y - 20, 30, 15); ctx.fillRect(x, y - 30, 10, 10); ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(x + 10, y - 8, 8, 0, Math.PI * 2); ctx.arc(x - 12, y - 5, 4, 0, Math.PI * 2); ctx.fill(); } else if (obj.type === 'car') { if (!obj.details.color) obj.details.color = `hsl(${180 + Math.random() * 60},50%,50%)`; ctx.fillStyle = obj.details.color; ctx.fillRect(x - 20, y - 15, 40, 10); ctx.beginPath(); ctx.roundRect(x - 15, y - 25, 30, 10, [5, 5, 0, 0]); ctx.fill(); ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(x - 10, y - 5, 4, 0, Math.PI * 2); ctx.arc(x + 10, y - 5, 4, 0, Math.PI * 2); ctx.fill(); } break; } }
        function updateLandscape(dt) { const viewWidth = window.innerWidth; mountains.forEach(l => { l.offsetX -= gameSpeed * l.speedMultiplier * dt; if (l.offsetX < -viewWidth * 2) l.offsetX += viewWidth * 2; }); landscapeLayers.forEach(l => { l.offsetX -= gameSpeed * l.speedMultiplier * dt; if (l.offsetX < -viewWidth * 2) l.offsetX += viewWidth * 2; l.objects.forEach(obj => { if (obj.type === 'sheep' || obj.type === 'horse') { obj.details.timer -= dt; if (obj.details.timer <= 0) { obj.details.state = (obj.details.state === 'down') ? 'up' : 'down'; obj.details.timer = 1 + Math.random() * 2; } } }); }); }
        let obstacles = []; function calculateNextObstacleTime() { const { minObstacleInterval, maxObstacleInterval } = currentDifficulty; nextObstacleTime = totalTime + (Math.random() * (maxObstacleInterval - minObstacleInterval) + minObstacleInterval); }
        function generateObstacle() { const r = Math.random(); let o = { x: window.innerWidth, width: 20, height: 40, y: 0, type: 'ground' }; if (r < 0.7) { o.height = 25; o.width = 25; o.y = GROUND_Y - o.height; } else { o.height = 50; o.y = GROUND_Y - o.height; } obstacles.push(o); }
        function updateObstacles(dt) { if (totalTime >= nextObstacleTime) { generateObstacle(); calculateNextObstacleTime(); } for (let i = obstacles.length - 1; i >= 0; i--) { const o = obstacles[i]; o.x -= gameSpeed * dt; ctx.fillStyle = '#DC143C'; ctx.fillRect(o.x, o.y, o.width, o.height); const pH = { x: personaggio.x, y: personaggio.y - personaggio.height, width: personaggio.width, height: personaggio.height }; const oH = { x: o.x, y: o.y, width: o.width, height: o.height }; if (!isInvincible && !isDemoMode && pH.x < oH.x + oH.width && pH.x + pH.width > oH.x && pH.y < oH.y + oH.height && pH.y + pH.height > oH.y) { handleCollision(); } if (o.x + o.width < 0) { obstacles.splice(i, 1); } } }
        function calculateNextSignTime() { nextSignTime = totalTime + 10 + Math.random() * 5; } function generateSign() { const sign = { x: window.innerWidth + 100, y: GROUND_Y, text: SIGN_TEXTS[currentSignIndex] }; signs.push(sign); currentSignIndex = (currentSignIndex + 1) % SIGN_TEXTS.length; }
        function updateAndDrawSigns(dt) { for (let i = signs.length - 1; i >= 0; i--) { const sign = signs[i]; sign.x -= gameSpeed * 0.4 * dt; const x = sign.x, y = sign.y; ctx.fillStyle = '#8B4513'; ctx.fillRect(x - 3, y - 50, 6, 50); ctx.fillStyle = '#1E90FF'; ctx.strokeStyle = 'white'; ctx.lineWidth = 3; ctx.fillRect(x - 50, y - 90, 100, 40); ctx.strokeRect(x - 50, y - 90, 100, 40); ctx.fillStyle = 'white'; ctx.font = 'bold 16px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(sign.text, x, y - 70); if (sign.x < -100) signs.splice(i, 1); } }
        function calculateNextSpectatorTime() { let proposedTime = totalTime + 3 + Math.random() * 5; if (Math.abs(proposedTime - nextSignTime) < 2.0) { proposedTime = nextSignTime + 2.0 + Math.random(); } nextSpectatorTime = proposedTime; }
        function generateSpectator() { const spectatorName = SPECTATOR_NAMES[currentSpectatorIndex]; currentSpectatorIndex = (currentSpectatorIndex + 1) % SPECTATOR_NAMES.length; const side = Math.random() < 0.5 ? 'left' : 'right'; const spectator = { x: window.innerWidth + 50, y: GROUND_Y, name: spectatorName, side: side, signColor: '#FFD700', animationTime: 0 }; spectators.push(spectator); }
        function isNearSign(spectatorX) { for (let sign of signs) { const distance = Math.abs(spectatorX - sign.x); if (distance < 150) { return true; } } return false; }
        function drawSpectator(spectator, x, y, dt) { const spectatorX = spectator.side === 'left' ? x - 60 : x + 60; const spectatorY = y; if (isNearSign(spectatorX)) return; spectator.animationTime += dt * 30; ctx.save(); ctx.strokeStyle = 'black'; ctx.lineWidth = 2; ctx.lineCap = 'round'; const headRadius = 6; const headY = spectatorY - 40; ctx.beginPath(); ctx.arc(spectatorX, headY, headRadius, 0, Math.PI * 2); ctx.stroke(); const torsoStartY = headY + headRadius; const torsoEndY = spectatorY - 15; ctx.beginPath(); ctx.moveTo(spectatorX, torsoStartY); ctx.lineTo(spectatorX, torsoEndY); ctx.stroke(); const armAnimationOffset = Math.sin(spectator.animationTime) * 15; const leftArmX = spectatorX - 10 + armAnimationOffset; const rightArmX = spectatorX + 10 - armAnimationOffset; const armY = torsoEndY - 5 + Math.abs(armAnimationOffset) * 0.3; ctx.beginPath(); ctx.moveTo(spectatorX, torsoEndY - 10); ctx.lineTo(leftArmX, armY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(spectatorX, torsoEndY - 10); ctx.lineTo(rightArmX, armY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(spectatorX, torsoEndY); ctx.lineTo(spectatorX - 8, spectatorY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(spectatorX, torsoEndY); ctx.lineTo(spectatorX + 8, spectatorY); ctx.stroke(); ctx.restore(); const signX = spectatorX; const signY = headY - 20; const signWidth = Math.max(80, spectator.name.length * 10); const signHeight = 28; ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(signX, signY); ctx.lineTo(signX, headY - headRadius); ctx.stroke(); ctx.fillStyle = spectator.signColor; ctx.strokeStyle = 'black'; ctx.lineWidth = 2; ctx.fillRect(signX - signWidth / 2, signY - signHeight, signWidth, signHeight); ctx.strokeRect(signX - signWidth / 2, signY - signHeight, signWidth, signHeight); ctx.fillStyle = 'black'; ctx.font = 'bold 16px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(spectator.name, signX, signY - signHeight / 2); }
        function updateAndDrawSpectators(dt) { for (let i = spectators.length - 1; i >= 0; i--) { const spectator = spectators[i]; spectator.x -= gameSpeed * 0.4 * dt; drawSpectator(spectator, spectator.x, spectator.y, dt); if (spectator.x < -100) spectators.splice(i, 1); } }
        const personaggio = { x: 0, y: 0, width: 30, height: 50, velocityY: 0, isJumping: false, draw() { ctx.save(); ctx.fillStyle = 'black'; const runCycle = Math.floor(totalTime * 15) % 2; const legAngle = runCycle === 0 ? Math.PI / 10 : -Math.PI / 10; const armAngle = runCycle === 0 ? -Math.PI / 8 : Math.PI / 8; ctx.fillStyle = '#333333'; ctx.beginPath(); ctx.roundRect(this.x + 5, this.y - 45, 20, 30, 5); ctx.fill(); ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y - 50, 10, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = '#333333'; ctx.lineWidth = 4; ctx.lineCap = 'round'; ctx.save(); ctx.translate(this.x + 5, this.y - 40); ctx.rotate(armAngle); ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, 20); ctx.stroke(); ctx.restore(); ctx.save(); ctx.translate(this.x + 25, this.y - 40); ctx.rotate(-armAngle); ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, 20); ctx.stroke(); ctx.restore(); ctx.strokeStyle = '#333333'; ctx.lineWidth = 5; ctx.save(); ctx.translate(this.x + 10, this.y - 15); ctx.rotate(legAngle); ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, 15); ctx.stroke(); ctx.restore(); ctx.save(); ctx.translate(this.x + 20, this.y - 15); ctx.rotate(-legAngle); ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, 15); ctx.stroke(); ctx.restore(); ctx.restore(); this.disegnaNome(); }, disegnaNome() { const offsetLineY = 30; const boxWidth = 120, boxHeight = 25; const lineX = this.x + this.width / 2; const lineY = this.y - this.height - 10; const boxX = lineX - boxWidth / 2; const boxY = lineY - offsetLineY - boxHeight; ctx.beginPath(); ctx.moveTo(lineX, lineY); ctx.lineTo(lineX, boxY + boxHeight); ctx.strokeStyle = 'black'; ctx.stroke(); ctx.fillStyle = 'white'; ctx.strokeStyle = 'black'; ctx.fillRect(boxX, boxY, boxWidth, boxHeight); ctx.strokeRect(boxX, boxY, boxWidth, boxHeight); ctx.fillStyle = 'black'; ctx.font = '16px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(PLAYER_NAME, lineX, boxY + boxHeight / 2); }, update(dt) { this.velocityY += GRAVITY * dt; this.y += this.velocityY * dt; if (this.y > GROUND_Y) { this.y = GROUND_Y; this.velocityY = 0; this.isJumping = false; } }, jump() { if (!this.isJumping && isAlive) { this.velocityY = JUMP_FORCE; this.isJumping = true; if (!isDemoMode) playSound('jump'); } } };
        function autopilot() { const o = obstacles.find(obs => obs.x + obs.width > personaggio.x); if (!o) return; const d = o.x - (personaggio.x + personaggio.width); const rD = gameSpeed * 0.45; if (d > 0 && d < rD) { personaggio.jump(); } }
        function startGame() { isAlive = true; hasStarted = true; score = 0; gameSpeed = currentDifficulty.initialSpeed; obstacles = []; signs = []; spectators = []; currentSignIndex = 0; currentSpectatorIndex = 0; personaggio.y = GROUND_Y; personaggio.velocityY = 0; leon.x = personaggio.x - 30; leon.y = GROUND_Y; leon.direction = 1; leon.animationTime = 0; leon.movementPhase = 'forward'; totalTime = 0; lastTime = 0; lives = INITIAL_LIVES; isInvincible = false; invincibilityTimer = 0; timeOfDay = 0; isRaining = false; if (!isDemoMode) demoDayCount = 0; initLandscape(); calculateNextObstacleTime(); nextSignTime = 0.5 + Math.random() * 2.5; nextSpectatorTime = 5 + Math.random() * 3; }
        function triggerGameOver() { isAlive = false; if (score > highscore) highscore = score; }
        function handleCollision() { playSound('fail'); screenFlashTimer = 0.2; lives--; if (lives <= 0) { triggerGameOver(); } else { isInvincible = true; invincibilityTimer = 2.0; } }
        
        // --- UI ---
        function drawLives() { const t = `Vite: ${lives}`; ctx.font = '22px sans-serif'; const m = ctx.measureText(t); const bW = m.width + 20; const bH = 35; const bX = 50, bY = 50; ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.beginPath(); ctx.roundRect(bX, bY, bW, bH, 8); ctx.fill(); ctx.fillStyle = 'black'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle'; ctx.fillText(t, bX + 10, bY + bH / 2 + 1); }
        function drawDigitalClock(simulatedHour) { const hour = Math.floor(simulatedHour); const minute = Math.floor((simulatedHour * 60) % 60); const timeString = `${String(hour).padStart(2,'0')}:${String(minute).padStart(2,'0')}`; ctx.font = '22px sans-serif'; const textMetrics = ctx.measureText(timeString); const boxWidth = textMetrics.width + 20; const livesText = `Vite: ${lives}`; ctx.font = '22px sans-serif'; const livesMetrics = ctx.measureText(livesText); const livesBoxWidth = livesMetrics.width + 20; const clockX = 50 + livesBoxWidth + 15; ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.beginPath(); ctx.roundRect(clockX, 50, boxWidth, 35, 8); ctx.fill(); ctx.fillStyle = 'black'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle'; ctx.font = '22px sans-serif'; ctx.fillText(timeString, clockX + 10, 50 + 35 / 2 + 1); }
        function drawScore() { const viewWidth = window.innerWidth; const scoreText = `${formatTime(score)}`; const hiScoreText = `HI ${formatTime(highscore)}`; ctx.font = '22px sans-serif'; const scoreMetrics = ctx.measureText(scoreText); const hiScoreMetrics = ctx.measureText(hiScoreText); const scoreBW = scoreMetrics.width + 20; const hiScoreBW = hiScoreMetrics.width + 20; const bH = 35; const exitButtonSize = 35; const exitButtonX = (viewWidth - exitButtonSize) / 2; const exitButtonY = 50; ctx.fillStyle = '#ff4444'; ctx.beginPath(); ctx.roundRect(exitButtonX, exitButtonY, exitButtonSize, exitButtonSize, 8); ctx.fill(); ctx.strokeStyle = 'white'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(exitButtonX + 10, exitButtonY + 10); ctx.lineTo(exitButtonX + 25, exitButtonY + 25); ctx.moveTo(exitButtonX + 25, exitButtonY + 10); ctx.lineTo(exitButtonX + 10, exitButtonY + 25); ctx.stroke(); window.exitGameButtonBounds = { x: exitButtonX, y: exitButtonY, width: exitButtonSize, height: exitButtonSize }; const hiScoreBX = viewWidth - hiScoreBW - 50; const scoreBX = hiScoreBX - scoreBW - 15; const bY = 50; ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.beginPath(); ctx.roundRect(scoreBX, bY, scoreBW, bH, 8); ctx.fill(); ctx.fillStyle = 'black'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle'; ctx.fillText(scoreText, scoreBX + 10, bY + bH / 2 + 1); ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.beginPath(); ctx.roundRect(hiScoreBX, bY, hiScoreBW, bH, 8); ctx.fill(); ctx.fillStyle = 'black'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle'; ctx.fillText(hiScoreText, hiScoreBX + 10, bY + bH / 2 + 1); }
        function showGameOverOverlay() { const viewWidth = window.innerWidth; const viewHeight = window.innerHeight; ctx.fillStyle = 'rgba(255,255,224,0.7)'; ctx.fillRect(0,0,viewWidth,viewHeight); ctx.fillStyle = 'black'; ctx.font = '40px sans-serif'; ctx.textAlign = 'center'; ctx.fillText('Game Over!', viewWidth/2, viewHeight/2 - 20); ctx.font = '20px sans-serif'; ctx.fillText(`Punteggio: ${formatTime(score)}. Clicca per riprovare.`, viewWidth/2, viewHeight/2 + 20); }
        
        function drawDifficultyScreen() {
            const viewWidth = window.innerWidth;
            const viewHeight = window.innerHeight;
            
            ctx.fillStyle = '#e0e0e0';
            ctx.fillRect(0, 0, viewWidth, viewHeight);

            const imgSize = Math.min(100, viewWidth * 0.25);
            const imgX = (viewWidth - imgSize) / 2;
            const imgY = viewHeight * 0.08;
            if (runnerImage.complete) {
                ctx.drawImage(runnerImage, imgX, imgY, imgSize, imgSize);
            }

            const fontSize = Math.max(16, viewHeight * 0.035);
            ctx.font = `bold ${fontSize}px sans-serif`;

            difficultyButtons.forEach(btn => {
                const textMetrics = ctx.measureText(btn.level.name);
                const textPaddingX = fontSize * 2.5;
                const textPaddingY = fontSize * 0.6;
                btn.width = textMetrics.width + textPaddingX * 2;
                btn.height = fontSize + textPaddingY * 2;
            });

            const maxRowWidth = difficultyButtons.slice(0, 3).reduce((sum, btn) => sum + btn.width, 0) + (2 * 20);
            const buttonsPerRow = (maxRowWidth < viewWidth * 0.9) ? 3 : 2;
            
            const rows = [];
            for (let i = 0; i < difficultyButtons.length; i += buttonsPerRow) {
                rows.push(difficultyButtons.slice(i, i + buttonsPerRow));
            }

            const rowSpacing = 20;
            const totalRowsHeight = (rows.length * difficultyButtons[0].height) + ((rows.length - 1) * rowSpacing);
            const gridTopY = imgY + imgSize + 30;
            const availableGridHeight = viewHeight - gridTopY - (viewHeight * 0.05);
            let currentY = gridTopY + (availableGridHeight - totalRowsHeight) / 2;

            rows.forEach(row => {
                const totalRowWidth = row.reduce((sum, btn) => sum + btn.width, 0) + ((row.length - 1) * 20);
                let currentX = (viewWidth - totalRowWidth) / 2;

                row.forEach(btn => {
                    btn.x = currentX;
                    btn.y = currentY;

                    ctx.shadowColor = 'rgba(0, 0, 0, 0.15)'; ctx.shadowBlur = 10; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 4;
                    ctx.fillStyle = '#3498db';
                    ctx.beginPath(); ctx.roundRect(btn.x, btn.y, btn.width, btn.height, 10); ctx.fill();
                    ctx.shadowColor = 'transparent';
                    
                    ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(btn.level.name, btn.x + btn.width / 2, btn.y + btn.height / 2 + 2);

                    currentX += btn.width + 20;
                });
                currentY += difficultyButtons[0].height + rowSpacing;
            });
        }
        
        function setupDifficultyButtons() { 
            difficultyButtons.length = 0; 
            Object.values(difficulties).forEach((level) => { difficultyButtons.push({ level: level }); }); 
            difficultyButtons.push({ level: { name: 'Demo' }, type: 'demo' });
            difficultyButtons.push({ level: { name: 'Cast' }, type: 'cast' });
            difficultyButtons.push({ level: { name: 'Info' }, type: 'info' });
        }
        
        function drawCastScreen() {
            const viewWidth = window.innerWidth;
            const viewHeight = window.innerHeight;

            ctx.fillStyle = '#E6F3FF'; ctx.fillRect(0, 0, viewWidth, viewHeight);

            const titleFontSize = Math.max(24, viewWidth * 0.05);
            ctx.fillStyle = '#333333';
            ctx.font = `bold ${titleFontSize}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText('Cast', viewWidth / 2, 60);

            const closeSize = 40; const closeX = viewWidth - closeSize - 20; const closeY = 40;
            ctx.fillStyle = '#333333'; ctx.beginPath(); ctx.roundRect(closeX, closeY, closeSize, closeSize, 8); ctx.fill(); 
            ctx.strokeStyle = 'white'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(closeX + 10, closeY + 10); ctx.lineTo(closeX + 30, closeY + 30); ctx.moveTo(closeX + 30, closeY + 10); ctx.lineTo(closeX + 10, closeY + 30); ctx.stroke();
            window.closeButtonBounds = { x: closeX, y: closeY, width: closeSize, height: closeSize };

            const padding = 30;
            let contentY = 120;
            const normalFontSize = Math.max(18, Math.min(22, viewWidth * 0.04));
            const lineHeight = normalFontSize * 1.5;
            const emojiSize = normalFontSize * 2;
            
            const cast = [
                { emoji: 'ðŸƒðŸ»â€â™‚ï¸â€âž¡ï¸', title: 'Protagonista:', text: PLAYER_NAME },
                { emoji: 'ðŸš¶ðŸ»â€â™‚ï¸â€âž¡ï¸', title: 'Tifosi:', text: SPECTATOR_NAMES.join(', ') },
                { emoji: 'ðŸ ', title: 'Luoghi:', text: SIGN_TEXTS.join(', ') },
                { emoji: 'ðŸ§‘â€ðŸ¤â€ðŸ§‘', title: 'Collaboratori:', text: 'Anna Schirone e Rino Volpe' }
            ];

            ctx.textAlign = 'left';
            cast.forEach(item => {
                let currentX = padding;
                const textMaxWidth = viewWidth - (padding * 2);

                ctx.font = `${emojiSize}px sans-serif`;
                ctx.textBaseline = 'top';
                ctx.fillText(item.emoji, currentX, contentY);
                currentX += ctx.measureText(item.emoji).width + 10;
                
                const fullText = `${item.title} ${item.text}`;
                ctx.font = `${normalFontSize}px sans-serif`;
                ctx.fillStyle = '#555555';
                
                const words = fullText.split(' ');
                let line = '';
                for (let n = 0; n < words.length; n++) {
                    let testLine = line + words[n] + ' ';
                    if (currentX + ctx.measureText(testLine).width > viewWidth - padding && n > 0) {
                        ctx.fillText(line, currentX, contentY);
                        line = words[n] + ' ';
                        contentY += lineHeight;
                        currentX = padding; 
                    } else {
                        line = testLine;
                    }
                }
                ctx.fillText(line, currentX, contentY);
                contentY += lineHeight + 15;
            });
        }
        
        function drawInfoScreen() {
            const viewWidth = window.innerWidth;
            const viewHeight = window.innerHeight;
            ctx.fillStyle = '#E6F3FF';
            ctx.fillRect(0, 0, viewWidth, viewHeight);

            const titleFontSize = Math.max(24, viewWidth * 0.05);
            ctx.fillStyle = '#333333';
            ctx.font = `bold ${titleFontSize}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText('Istruzioni', viewWidth / 2, 60);

            const closeSize = 40; const closeX = viewWidth - closeSize - 20; const closeY = 40;
            ctx.fillStyle = '#333333'; ctx.beginPath(); ctx.roundRect(closeX, closeY, closeSize, closeSize, 8); ctx.fill(); 
            ctx.strokeStyle = 'white'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(closeX + 10, closeY + 10); ctx.lineTo(closeX + 30, closeY + 30); ctx.moveTo(closeX + 30, closeY + 10); ctx.lineTo(closeX + 10, closeY + 30); ctx.stroke();
            window.closeButtonBounds = { x: closeX, y: closeY, width: closeSize, height: closeSize };
            
            const padding = 30; const textY = 120; const textAreaHeight = viewHeight - textY - padding;
            const lines = [ { text: 'Clicca o premi SPAZIO per saltare.', style: 'normal' }, { text: 'Evita gli ostacoli rossi!', style: 'normal' }, { text: 'Corri il piÃ¹ lontano possibile.', style: 'normal' }, { text: '', style: 'normal' }, { text: 'Per dispositivi mobili:', style: 'header' }, { text: 'Aggiungi questa pagina alla schermata', style: 'small' }, { text: 'Home per un\'esperienza a schermo intero.', style: 'small' }, { text: '', style: 'normal' }, { text: 'Su iPhone/iPad:', style: 'header' }, { text: 'Usa l\'icona "Condividi" e seleziona', style: 'small' }, { text: '"Aggiungi alla schermata Home".', style: 'small' }, { text: '', style: 'normal' }, { text: 'Su Android:', style: 'header' }, { text: 'Usa il menu (â‹®) e seleziona', style: 'small' }, { text: '"Aggiungi a schermata Home".', style: 'small' } ];
            const normalFontSize = Math.max(16, Math.min(22, viewWidth * 0.04)); const headerFontSize = normalFontSize * 1.1; const smallFontSize = normalFontSize * 0.9; const lineHeight = normalFontSize * 1.5;
            const totalTextHeight = lines.length * lineHeight; if (!window.infoScrollY) window.infoScrollY = 0; const maxScrollY = Math.max(0, totalTextHeight - textAreaHeight); window.infoScrollY = Math.max(0, Math.min(window.infoScrollY, maxScrollY));
            
            ctx.save(); ctx.beginPath(); ctx.rect(padding, textY, viewWidth - (padding*2), textAreaHeight); ctx.clip();
            ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            lines.forEach((line, index) => { const lineY = textY + (index * lineHeight) - window.infoScrollY; if (line.style === 'header') ctx.font = `bold ${headerFontSize}px sans-serif`; else if (line.style === 'small') ctx.font = `${smallFontSize}px sans-serif`; else ctx.font = `${normalFontSize}px sans-serif`; ctx.fillText(line.text, viewWidth / 2, lineY); });
            ctx.restore();
            
            if (maxScrollY > 0) { const scrollBarWidth = 12; const scrollBarX = viewWidth - padding; const scrollBarY = textY; const scrollBarHeight = textAreaHeight; ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; ctx.beginPath(); ctx.roundRect(scrollBarX, scrollBarY, scrollBarWidth, scrollBarHeight, 6); ctx.fill(); const cursorHeight = Math.max(30, (textAreaHeight / totalTextHeight) * scrollBarHeight); const cursorY = scrollBarY + (window.infoScrollY / maxScrollY) * (scrollBarHeight - cursorHeight); ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; ctx.beginPath(); ctx.roundRect(scrollBarX, cursorY, scrollBarWidth, cursorHeight, 6); ctx.fill(); window.scrollBarBounds = { x: scrollBarX, y: scrollBarY, width: scrollBarWidth, height: scrollBarHeight, maxScrollY: maxScrollY }; } else { window.scrollBarBounds = null; }
        }

        // --- LOOP PRINCIPALE ---
        function gameLoop(timestamp) {
            if (!lastTime) { lastTime = timestamp; requestAnimationFrame(gameLoop); return; }
            let deltaTime = (timestamp - lastTime) / 1000; lastTime = timestamp; if (deltaTime > 0.1) { deltaTime = 1 / 60; }
            
            if (showInfoScreen) { drawInfoScreen(); } 
            else if (showCastScreen) { drawCastScreen(); } 
            else if (!hasStarted) { drawDifficultyScreen(); } 
            else {
                const viewWidth = window.innerWidth;
                const simulatedHour = (7 + (timeOfDay / DAY_CYCLE_DURATION) * 24) % 24;
                drawSky(simulatedHour); drawLandscape(simulatedHour); updateAndDrawSigns(deltaTime); updateAndDrawSpectators(deltaTime); drawGround(); drawRain(deltaTime); drawScore(); drawLives(); drawDigitalClock(simulatedHour);
                if (isAlive) {
                    timeOfDay = (timeOfDay + deltaTime) % DAY_CYCLE_DURATION; toggleRain(deltaTime);
                    if (isDemoMode && timeOfDay < deltaTime) { demoDayCount++; const difficultyNames = ['facile', 'medio', 'difficile']; const currentDifficultyName = difficultyNames[demoDayCount % 3]; currentDifficulty = difficulties[currentDifficultyName]; gameSpeed = currentDifficulty.initialSpeed; calculateNextObstacleTime(); }
                    if (totalTime >= nextSignTime) { generateSign(); calculateNextSignTime(); }
                    if (totalTime >= nextSpectatorTime) { generateSpectator(); calculateNextSpectatorTime(); }
                    totalTime += deltaTime; score += deltaTime * 10; gameSpeed += currentDifficulty.speedIncrement * deltaTime; if (isInvincible) { invincibilityTimer -= deltaTime; if (invincibilityTimer <= 0) isInvincible = false; }
                    if (isDemoMode) autopilot(); personaggio.update(deltaTime); leon.update(deltaTime, viewWidth); updateLandscape(deltaTime); updateObstacles(deltaTime);
                } else { showGameOverOverlay(); }
                leon.draw(); if (!(isInvincible && Math.floor(totalTime * 10) % 2 !== 0)) { personaggio.draw(); }
                if (isDemoMode) { ctx.fillStyle = 'rgba(255,255,255,0.8)'; ctx.font = '16px sans-serif'; ctx.textAlign = 'center'; ctx.fillText(`Demo - ${currentDifficulty.name} (Giorno ${demoDayCount + 1})`, viewWidth / 2, window.innerHeight - 30); }
            }
            requestAnimationFrame(gameLoop);
        }

        function drawGround() { ctx.fillStyle = '#A0522D'; ctx.fillRect(0, GROUND_Y, window.innerWidth, window.innerHeight - GROUND_Y); ctx.strokeStyle = '#333'; ctx.beginPath(); ctx.moveTo(0, GROUND_Y); ctx.lineTo(window.innerWidth, GROUND_Y); ctx.stroke(); }
        function formatTime(s) { const tS = Math.floor(s / 10); const m = Math.floor(tS / 60); const sec = tS % 60; return `${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}`; }
        function resetToMenu() { hasStarted = false; isAlive = false; isDemoMode = false; showInfoScreen = false; showCastScreen = false; score = 0; obstacles = []; spectators = []; personaggio.y = GROUND_Y; personaggio.velocityY = 0; stopInfoAudio(); window.infoScrollY = 0; setupDifficultyButtons(); }
        
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const viewWidth = window.innerWidth;
            const viewHeight = window.innerHeight;
            canvas.width = viewWidth * dpr;
            canvas.height = viewHeight * dpr;
            canvas.style.width = viewWidth + 'px';
            canvas.style.height = viewHeight + 'px';
            ctx.scale(dpr, dpr);
            GROUND_Y = viewHeight - 50; 
            personaggio.x = viewWidth * 0.15;
            leon.y = GROUND_Y; 
            initLandscape(); 
            setupDifficultyButtons(); 
        }

        // --- GESTIONE INPUT ---
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                unlockAudio();
                if (hasStarted) {
                    if (isAlive && !isDemoMode) personaggio.jump();
                } else if (!showInfoScreen && !showCastScreen) {
                    currentDifficulty = difficulties.facile;
                    startGame();
                }
            }
            if (e.code === 'Escape') { e.preventDefault(); resetToMenu(); }
            if (showInfoScreen) { if (e.code === 'ArrowUp' || e.code === 'ArrowDown') { e.preventDefault(); if (!window.infoScrollY) window.infoScrollY = 0; const scrollAmount = 30; if (e.code === 'ArrowUp') window.infoScrollY = Math.max(0, window.infoScrollY - scrollAmount); else { const maxScroll = window.scrollBarBounds ? window.scrollBarBounds.maxScrollY : 0; window.infoScrollY = Math.min(maxScroll, window.infoScrollY + scrollAmount); } } }
        });
        canvas.addEventListener('mousedown', (e) => { unlockAudio(); handleInteraction(e); });
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); unlockAudio(); handleInteraction(e); }, {passive:false});
        canvas.addEventListener('wheel', (e) => { if (showInfoScreen) { e.preventDefault(); if (!window.infoScrollY) window.infoScrollY = 0; const scrollAmount = e.deltaY > 0 ? 30 : -30; const maxScroll = window.scrollBarBounds ? window.scrollBarBounds.maxScrollY : 0; window.infoScrollY = Math.max(0, Math.min(maxScroll, window.infoScrollY + scrollAmount)); } });
        window.addEventListener('resize', resizeCanvas);

        function handleInteraction(event) {
            const r = canvas.getBoundingClientRect(); 
            const x = (event.clientX || (event.touches && event.touches[0].clientX) || 0) - r.left; 
            const y = (event.clientY || (event.touches && event.touches[0].clientY) || 0) - r.top;
            
            if (showInfoScreen || showCastScreen) {
                if (window.closeButtonBounds && x > window.closeButtonBounds.x && x < window.closeButtonBounds.x + window.closeButtonBounds.width && y > window.closeButtonBounds.y && y < window.closeButtonBounds.y + window.closeButtonBounds.height) { 
                    showInfoScreen = false; showCastScreen = false; stopInfoAudio(); window.infoScrollY = 0; return; 
                }
                if (showInfoScreen && window.scrollBarBounds && x > window.scrollBarBounds.x && x < window.scrollBarBounds.x + window.scrollBarBounds.width && y > window.scrollBarBounds.y && y < window.scrollBarBounds.y + window.scrollBarBounds.height) {
                    const relativeY = y - window.scrollBarBounds.y;
                    window.infoScrollY = (relativeY / window.scrollBarBounds.height) * window.scrollBarBounds.maxScrollY;
                }
                return;
            }
            
            if (!hasStarted) {
                const clickedBtn = difficultyButtons.find(btn => x > btn.x && x < btn.x + btn.width && y > btn.y && y < btn.y + btn.height);
                if (clickedBtn) {
                    if (clickedBtn.type === 'demo') { isDemoMode = true; demoDayCount = 0; currentDifficulty = difficulties.facile; startGame(); }
                    else if (clickedBtn.type === 'info') { showInfoScreen = true; window.infoScrollY = 0; playInfoAudio(); }
                    else if (clickedBtn.type === 'cast') { showCastScreen = true; }
                    else { isDemoMode = false; currentDifficulty = clickedBtn.level; startGame(); }
                }
            } else if (!isAlive) { 
                startGame(); 
            } else { 
                if (window.exitGameButtonBounds && x > window.exitGameButtonBounds.x && x < window.exitGameButtonBounds.x + window.exitGameButtonBounds.width && y > window.exitGameButtonBounds.y && y < window.exitGameButtonBounds.y + window.exitGameButtonBounds.height) {
                    resetToMenu();
                    return;
                }
                personaggio.jump(); 
            }
        }

        // --- INIT ---
        resizeCanvas();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>